{{ define "summary_all.gohtml" }}
<!doctype html>
<html lang="gl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Resumo global — {{ .concello }}</title>
  <link rel="stylesheet" href="/static/pico.min.css">
  <link rel="stylesheet" href="/static/compact.css">

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    header.nav { position: sticky; top: 0; backdrop-filter: blur(6px); }
    .grid { display: grid; gap: 1.25rem; grid-template-columns: repeat(12, 1fr); }
    .card { padding: 1rem; border: 1px solid rgba(0,0,0,.08); border-radius: .5rem; }
    .span-6 { grid-column: span 6; }
    .span-12{ grid-column: span 12; }
    @media (max-width: 1024px){ .span-6{ grid-column: span 12; } }
    canvas { max-height: 460px; }
    .toolbar { display: grid; gap: .75rem; grid-template-columns: 1fr auto; align-items: end; }
    #chartAdxTop{max-height:640px}

    /* + ALTURA extra para as dúas gráficas de “tipo” */
    #chartTipos, #chartImpTipos { height: 520px; max-height: 520px; }

    /* + A tarta máis grande */
    #chartAnexos { height: 420px; max-height: 420px; }

    /* Se usas a grella 12 columnas, a tarta en 6 para non quedar enana */
    @media (min-width: 900px){
      .span-6-md { grid-column: span 6; }
    }
  </style>

  <script>
  // Plugin: pon cursor "pointer" se o elemento baixo o rato ten URL asociada
  const cursorLinkPlugin = {
    id: 'cursorLinkPlugin',
    afterEvent(chart, args) {
      const els = chart.getActiveElements();
      const urls = chart.options.linkUrls || [];
      chart.canvas.style.cursor = (els && els.length && urls[els[0].index]) ? 'pointer' : 'default';
    }
  };
  Chart.register(cursorLinkPlugin);
  </script>
</head>

<body>
  <header class="container-fluid nav">
    <nav>
      <ul><li><strong>Resumo global {{ .concello }}</strong></li></ul>
      <ul>
        <li><a href="/">Index</a></li>
      </ul>
    </nav>
  </header>

  <main class="container">
    {{ template "partials/menu" . }}

    <header class="controls">
      <input id="q" type="search" placeholder="Instant search (≥ 3 caracteres adxudicatario, obxecto, importe...)" value="{{ .Q }}">
    </header>

    <!-- graficas -->
    <div class="grid">
      <section class="card span-12">
        <h3>Número de adxudicacións e importes por mes</h3>
        <canvas id="chartAdxMensuais"></canvas>
        <p><small>Podes buscar por datas aprox. (<code>2024-09</code>), por adxudicatario (só en <code>_contratos_menores</code> polo de agora), por importe (<code>1.121.154,74 ou 1160 ou 10.719,93</code>)</small></p>
      </section>

      <section class="card span-6">
        <h3>Número por tipo</h3>
        <canvas id="chartTipos"></canvas>
      </section>

      <section class="card span-6">
        <h3>Importe total por tipo</h3>
        <canvas id="chartImpTipos"></canvas>
      </section>

      <section class="card span-12">
        <h3>Top 10 adxudicatarios</h3>
        <canvas id="chartAdxTop"></canvas>
      </section>

      <section class="card span-12">
        <h3>Top 20 maiores licitacións</h3>
        <canvas id="chartTopImportes"></canvas>
      </section>

      <section class="card span-6 span-6-md">
        <h3>Con anexos</h3>
        <canvas id="chartAnexos"></canvas>
      </section>
    </div>
  </main>

  <script>
  // ========= Cores centralizadas e helpers =========
  // as cores comentadas están fixadas explicitamente, ver FIXED. O vermello é a linha de "Importe"
  const PALETTE = [
    // ['rgba(33,150,243,0.7)','rgba(33,150,243,1)'],
    ['rgba(76,175,80,0.7)','rgba(76,175,80,1)'],
    ['rgba(255,152,0,0.7)','rgba(255,152,0,1)'],
    // ['rgba(156,39,176,0.7)','rgba(156,39,176,1)'],
    // ['rgba(244,67,54,0.7)','rgba(244,67,54,1)'],
    ['rgba(0,188,212,0.7)','rgba(0,188,212,1)'],
    ['rgba(121,85,72,0.7)','rgba(121,85,72,1)'],
    ['rgba(63,81,181,0.7)','rgba(63,81,181,1)'],
    // ['rgba(205,220,57,0.7)','rgba(205,220,57,1)'],
    // ['rgba(158,158,158,0.7)','rgba(158,158,158,1)'],
  ];

  // cores fixas
  const FIXED = {
    'Alcaldia_contratos_menores': ['rgba(33,150,243,0.7)','rgba(33,150,243,1)'],
    'Xunta_de_Goberno_licitacions': ['rgba(156,39,176,0.7)','rgba(156,39,176,1)'],
    'Pleno_licitacions': ['rgba(205,220,57,0.7)','rgba(205,220,57,1)'],
    'Xerencia_EPEL_contratos_menores': ['rgba(158,158,158,0.7)','rgba(158,158,158,1)'],
  };

  function colorForSeries(name) {
    if (FIXED[name]) return FIXED[name];
    const idx = hashStr(String(name || '')) % PALETTE.length;
    return PALETTE[idx];
  }

  // Suma todos os segmentos 'bar' da categoría (dataIndex) corrente
  function stackTotalAt(chart, dataIndex){
    let total = 0;
    for (const ds of chart.data.datasets){
      if (ds.type === 'bar') {
        const v = Number((ds.data && ds.data[dataIndex]) || 0);
        if (Number.isFinite(v)) total += v;
      }
    }
    return total;
  }

  function hashStr(s){let h=5381;for(let i=0;i<s.length;i++)h=((h<<5)+h)+s.charCodeAt(i);return (h>>>0);}

  // devolve o valor correcto segundo a orientación do gráfico (en horizontais o valor está en parsed.x, no resto en parsed.y)
  function valueFromCtx(ctx){
    const axis = ctx?.chart?.options?.indexAxis;
    // en horizontais (indexAxis:'y') o dato vai en parsed.x
    return axis === 'y' ? ctx.parsed.x : ctx.parsed.y;
  }

  function tooltipLabelNoZeros(ctx){
    const v = valueFromCtx(ctx);
    if (v === 0) return null;
    if (ctx.dataset.type === 'line') {
      return ctx.dataset.label + ': ' +
        new Intl.NumberFormat('es-ES',{style:'currency',currency:'EUR'}).format(v);
    }
    return ctx.dataset.label + ': ' + v;
  }


  function buildStack(series, matrix){
    const ds=[];
    for(let i=0;i<(series||[]).length;i++){
      const [bg,b] = colorForSeries(series[i]);
      ds.push({
        type:'bar', label: series[i],
        data: (matrix && matrix[i]) ? matrix[i] : [],
        yAxisID:'y', backgroundColor:bg, borderColor:b, borderWidth:1, hoverBorderWidth:1
      });
    }
    return ds;
  }
  // ========= Fin helpers =========

  // Datos do servidor
  const AdxMesLabels      = {{ .AdxMesLabels }};
  const AdxMesImportes    = {{ .AdxMesImportes }};
  const AdxMesSeries      = {{ .AdxMesSeries }};
  const AdxMesCountsStack = {{ .AdxMesCountsStack }};

  const TiposLabels       = {{ .TiposLabels }};
  const TiposSeries       = {{ .TiposSeries }};
  const TiposCountsStack  = {{ .TiposCountsStack }};

  const ImpLabels         = {{ .ImpLabels }};
  const ImpSeries         = {{ .ImpSeries }};
  const ImpTotalsStack    = {{ .ImpTotalsStack }};

  const AdxLabels         = {{ .AdxLabels }};
  const AdxSeries         = {{ .AdxSeries }};
  const AdxCountsStack    = {{ .AdxCountsStack }};

  const TopLicLabels      = {{ .TopLicLabels }};
  const TopLicAmounts     = {{ .TopLicAmounts }};
  const TopLicURLs        = {{ .TopLicURLs }};
  const TopLicObjects     = {{ .TopLicObjects }};

  const AnexosLabels      = {{ .AnexosLabels }};
  const AnexosCounts      = {{ .AnexosCounts }};

  // refs aos charts para recreación
  let chAdxMensuais=null, chTipos=null, chImp=null, chAdx=null, chTop=null, chAnx=null;

  // Gráfica mensual (apilada + liña importes)
  function renderAdxMensuais(labels, series, matrix, importes){
    const el = document.getElementById('chartAdxMensuais');
    if (chAdxMensuais) { chAdxMensuais.destroy(); chAdxMensuais=null; }
    const ds = buildStack(series, matrix);
    ds.push({
      type:'line', label:'Importe total (€)', data: importes||[],
      yAxisID:'y1', borderColor:'rgba(255,99,132,1)', backgroundColor:'rgba(255,99,132,0.25)',
      borderWidth:2, pointRadius:2
    });
    chAdxMensuais = new Chart(el,{
      type:'bar',
      data:{ labels: labels||[], datasets: ds },
      options:{
        responsive:true, animation:false,
        interaction:{mode:'index',intersect:false,axis:'x'},
        scales:{
          x:{stacked:true},
          y:{stacked:true, beginAtZero:true, ticks:{ stepSize:1, callback:v=>Number.isInteger(v)?v:null }, title:{display:true,text:'Nº licitacións'}},
          y1:{position:'right', beginAtZero:true, grid:{drawOnChartArea:false},
              ticks:{callback:v=>new Intl.NumberFormat('es-ES',{style:'currency',currency:'EUR'}).format(v)},
              title:{display:true,text:'Importe total (€)'}}
        },
        plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label: tooltipLabelNoZeros } } }
      }
    });
  }

  // Gráfica “Número por Tipo”
  function renderTipos(labels, series, matrix){
    const el = document.getElementById('chartTipos');
    if (chTipos) { chTipos.destroy(); chTipos=null; }
    chTipos = new Chart(el,{
      type:'bar',
      data:{ labels: labels||[], datasets: buildStack(series, matrix) },
      options:{
        maintainAspectRatio: false, responsive:true, interaction:{mode:'index',intersect:false,axis:'x'},
        scales:{ x:{stacked:true}, y:{stacked:true, beginAtZero:true, ticks:{ stepSize:1, callback:v=>Number.isInteger(v)?v:null}}},
        plugins:{
          legend:{ display:true },
          tooltip:{
            callbacks:{
              // segue ocultando segmentos con 0
              label: tooltipLabelNoZeros,

              // engadimos un footer co TOTAL da barra apilada
              footer: (items) => {
                if (!items || !items.length) return '';
                const idx = items[0].dataIndex;
                const total = stackTotalAt(items[0].chart, idx);
                return 'Total: ' + total;
              }
            }
          }
        }
      }
    });
  }

  // Gráfica “Importe por Tipo”
  function renderImp(labels, series, matrix){
    const el = document.getElementById('chartImpTipos');
    if (chImp) { chImp.destroy(); chImp=null; }
    chImp = new Chart(el,{
      type:'bar',
      data:{ labels: labels||[], datasets: buildStack(series, matrix) },
      options:{
        maintainAspectRatio: false, responsive:true, interaction:{mode:'index',intersect:false,axis:'x'},
        scales:{
          x:{stacked:true},
          y:{stacked:true, beginAtZero:true,
             ticks:{ callback:v=>new Intl.NumberFormat('es-ES',{style:'currency',currency:'EUR'}).format(v)}}
        },
        plugins:{
          legend:{ display:true },
          tooltip:{
            callbacks:{
              // ocultar 0 e formatar € por segmento
              label: function(ctx){
                const v = (ctx.parsed && typeof ctx.parsed.y!=='undefined') ? ctx.parsed.y : ctx.parsed;
                if (v === 0) return null;
                return ctx.dataset.label + ': ' +
                  new Intl.NumberFormat('es-ES',{style:'currency',currency:'EUR'}).format(v);
              },

              // footer: TOTAL € da barra apilada
              footer: (items) => {
                if (!items || !items.length) return '';
                const idx = items[0].dataIndex;
                const total = stackTotalAt(items[0].chart, idx);
                return 'Total: ' + new Intl.NumberFormat('es-ES',{style:'currency',currency:'EUR'}).format(total);
              }
            }
          }
        }
      }
    });
  }

  // Gráfica “Top 10 adxudicatarios” (horizontal)
  function renderAdx(labels, series, matrix){
    const el = document.getElementById('chartAdxTop');
    if (chAdx) { chAdx.destroy(); chAdx=null; }
    chAdx = new Chart(el,{
      type:'bar',
      data:{ labels: labels||[], datasets: buildStack(series, matrix) },
      options:{
        indexAxis:'y',
        responsive:true, interaction:{mode:'index',intersect:false,axis:'y'},
        scales:{ y:{stacked:true}, x:{stacked:true, beginAtZero:true, ticks:{ stepSize:1, callback:v=>Number.isInteger(v)?v:null}}},
        plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label: tooltipLabelNoZeros } } }
      }
    });
  }

  // Gráfica “Top 20 importes”
  function renderTop(labels, amounts, urls, objects){
  const el = document.getElementById('chartTopImportes');
  if (chTop) { chTop.destroy(); chTop=null; }

  chTop = new Chart(el,{
    type:'bar',
    data:{
      labels: labels || [],
      datasets:[{
        type:'bar',
        label:'Importe (€)',
        data: amounts || [],
        borderWidth: 1,
        // feedback visual en hover (verde)
        hoverBackgroundColor: 'rgba(76, 175, 80, 0.7)',
        hoverBorderColor: 'rgba(76, 175, 80, 1)',
      }]
    },
    options:{
      indexAxis:'y',
      // gardamos as URLs aquí para poder consultalas en onHover / tooltip
      linkUrls: urls || [],
      linkObjects: objects || [],

      responsive:true,
      interaction:{ mode:'nearest', intersect:false }, // mellor detección
      plugins:{ 
        legend:{ display:false },
        tooltip:{ 
          callbacks:{
            title:(items)=> items[0]?.label || '',
            label:(ctx)=> 'Importe: ' + new Intl.NumberFormat('es-ES',{style:'currency',currency:'EUR'}).format(ctx.parsed.x),
            afterBody:(items)=>{
              const i = items[0].dataIndex;
              const u = (chTop.options.linkUrls||[])[i] || '';
              const exp = u.split('q=')[1] ? decodeURIComponent(u.split('q=')[1]) : '';
              const obj = (chTop.options.linkObjects||[])[i] || '';
              const lines=[];
              if (exp) lines.push('Expediente: '+exp);
              if (obj) lines.push('Objeto: '+obj);
              return lines;
            }
          }
        }
      },
      scales:{
        x:{ beginAtZero:true, ticks:{ callback:v=>new Intl.NumberFormat('es-ES',{style:'currency',currency:'EUR'}).format(v) } },
        y:{ ticks:{ autoSkip:false } }
      },

      // Cursor "pointer" só se hai URL na barra baixo o rato
      onHover: (event, elements, chart) => {
        const canvas = event?.native?.target || chart.canvas;
        let cursor = 'default';
        // usamos a detección "manual" para ser máis tolerantes
        const hits = chart.getElementsAtEventForMode(event, 'nearest', {intersect:false}, true);
        if (hits && hits.length) {
          const idx = hits[0].index;
          const href = (chart.options.linkUrls || [])[idx];
          if (href) cursor = 'pointer';
        }
        if (canvas) canvas.style.cursor = cursor;
      },

      // click abre nunha nova lapela
      onClick: (event, elements, chart)=>{
        const hits = chart.getElementsAtEventForMode(event, 'nearest', {intersect:false}, true);
        if (!hits || !hits.length) return;
        const idx = hits[0].index;
        const href = (chart.options.linkUrls || [])[idx];
        if (href) window.open(href, '_blank', 'noopener');
      }
    }
  });
}


  // Gráfica tarta “Con anexos”
  function renderAnexos(labels, counts){
    const el = document.getElementById('chartAnexos');
    if (chAnx) { chAnx.destroy(); chAnx=null; }
    chAnx = new Chart(el,{
      type:'pie',
      data:{ labels: labels||[], datasets:[{
        data: counts||[],
        backgroundColor:['rgba(76,175,80,0.7)','rgba(158,158,158,0.7)'],
        borderColor:['rgba(76,175,80,1)','rgba(158,158,158,1)'],
        borderWidth:1
      }]},
      options:{ responsive:true, plugins:{ legend:{position:'bottom'} } }
    });
  }

  // Render inicial (datos do servidor)
  renderAdxMensuais(AdxMesLabels, AdxMesSeries, AdxMesCountsStack, AdxMesImportes);
  renderTipos(TiposLabels, TiposSeries, TiposCountsStack);
  renderImp(ImpLabels, ImpSeries, ImpTotalsStack);
  renderAdx(AdxLabels, AdxSeries, AdxCountsStack);
  renderTop(TopLicLabels, TopLicAmounts, TopLicURLs, TopLicObjects);
  renderAnexos({{ .AnexosLabels }}, {{ .AnexosCounts }});

  // Instant Search
  const $q = document.getElementById('q');
  let t=null;
  function doFetch(){
    const v = $q.value.trim();
    const p = new URLSearchParams();
    if (v.length>=3) p.set('q', v);
    fetch('/api/summary_all?'+p.toString())
      .then(r=>r.json())
      .then(data=>{
        renderAdxMensuais(data.adxMesLabels, data.adxMesSeries, data.adxMesCountsStack, data.adxMesImportes);
        renderTipos(data.tiposLabels, data.tiposSeries, data.tiposCountsStack);
        renderImp(data.impLabels, data.impSeries, data.impTotalsStack);
        renderAdx(data.adxLabels, data.adxSeries, data.adxCountsStack);
        renderTop(data.topLicLabels, data.topLicAmounts, data.topLicUrls, data.topLicObjects);
        renderAnexos(data.anexosLabels, data.anexosCounts);
      })
      .catch(console.error);
  }
  $q.addEventListener('input', ()=>{ clearTimeout(t); t=setTimeout(doFetch, 200); });
  </script>
</body>
</html>
{{ end }}
